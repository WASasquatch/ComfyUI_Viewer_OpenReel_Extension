import{r as D,g as P,b as T}from"./react.js";const W={},w=e=>{let r;const n=new Set,o=(m,S)=>{const y=typeof m=="function"?m(r):m;if(!Object.is(y,r)){const l=r;r=S??(typeof y!="object"||y===null)?y:Object.assign({},r,y),n.forEach(h=>h(r,l))}},s=()=>r,v={setState:o,getState:s,getInitialState:()=>c,subscribe:m=>(n.add(m),()=>n.delete(m)),destroy:()=>{(W?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),n.clear()}},c=r=e(o,s,v);return v},A=e=>e?w(e):w;var j={exports:{}},z={},H={exports:{}},x={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var p=D;function J(e,r){return e===r&&(e!==0||1/e===1/r)||e!==e&&r!==r}var N=typeof Object.is=="function"?Object.is:J,U=p.useState,k=p.useEffect,L=p.useLayoutEffect,M=p.useDebugValue;function G(e,r){var n=r(),o=U({inst:{value:n,getSnapshot:r}}),s=o[0].inst,t=o[1];return L(function(){s.value=n,s.getSnapshot=r,I(s)&&t({inst:s})},[e,n,r]),k(function(){return I(s)&&t({inst:s}),e(function(){I(s)&&t({inst:s})})},[e]),M(n),n}function I(e){var r=e.getSnapshot;e=e.value;try{var n=r();return!N(e,n)}catch{return!0}}function B(e,r){return r()}var q=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?B:G;x.useSyncExternalStore=p.useSyncExternalStore!==void 0?p.useSyncExternalStore:q;H.exports=x;var K=H.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _=D,Q=K;function X(e,r){return e===r&&(e!==0||1/e===1/r)||e!==e&&r!==r}var Y=typeof Object.is=="function"?Object.is:X,Z=Q.useSyncExternalStore,V=_.useRef,ee=_.useEffect,te=_.useMemo,re=_.useDebugValue;z.useSyncExternalStoreWithSelector=function(e,r,n,o,s){var t=V(null);if(t.current===null){var d={hasValue:!1,value:null};t.current=d}else d=t.current;t=te(function(){function v(l){if(!c){if(c=!0,m=l,l=o(l),s!==void 0&&d.hasValue){var h=d.value;if(s(h,l))return S=h}return S=l}if(h=S,Y(m,l))return h;var u=o(l);return s!==void 0&&s(h,u)?(m=l,h):(m=l,S=u)}var c=!1,m,S,y=n===void 0?null:n;return[function(){return v(r())},y===null?void 0:function(){return v(y())}]},[r,n,o,s]);var f=Z(e,t[0],t[1]);return ee(function(){d.hasValue=!0,d.value=f},[f]),re(f),f};j.exports=z;var ne=j.exports;const oe=P(ne),F={},{useDebugValue:se}=T,{useSyncExternalStoreWithSelector:ie}=oe;let R=!1;const ae=e=>e;function ue(e,r=ae,n){(F?"production":void 0)!=="production"&&n&&!R&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),R=!0);const o=ie(e.subscribe,e.getState,e.getServerState||e.getInitialState,r,n);return se(o),o}const $=e=>{(F?"production":void 0)!=="production"&&typeof e!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const r=typeof e=="function"?A(e):e,n=(o,s)=>ue(r,o,s);return Object.assign(n,r),n},he=e=>e?$(e):$,ce={},le=e=>(r,n,o)=>{const s=o.subscribe;return o.subscribe=(d,f,v)=>{let c=d;if(f){const m=v?.equalityFn||Object.is;let S=d(o.getState());c=y=>{const l=d(y);if(!m(S,l)){const h=S;f(S=l,h)}},v?.fireImmediately&&f(S,S)}return s(c)},e(r,n,o)},ye=le;function de(e,r){let n;try{n=e()}catch{return}return{getItem:s=>{var t;const d=v=>v===null?null:JSON.parse(v,void 0),f=(t=n.getItem(s))!=null?t:null;return f instanceof Promise?f.then(d):d(f)},setItem:(s,t)=>n.setItem(s,JSON.stringify(t,void 0)),removeItem:s=>n.removeItem(s)}}const E=e=>r=>{try{const n=e(r);return n instanceof Promise?n:{then(o){return E(o)(n)},catch(o){return this}}}catch(n){return{then(o){return this},catch(o){return E(o)(n)}}}},fe=(e,r)=>(n,o,s)=>{let t={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:a=>a,version:0,merge:(a,g)=>({...g,...a}),...r},d=!1;const f=new Set,v=new Set;let c;try{c=t.getStorage()}catch{}if(!c)return e((...a)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),n(...a)},o,s);const m=E(t.serialize),S=()=>{const a=t.partialize({...o()});let g;const i=m({state:a,version:t.version}).then(b=>c.setItem(t.name,b)).catch(b=>{g=b});if(g)throw g;return i},y=s.setState;s.setState=(a,g)=>{y(a,g),S()};const l=e((...a)=>{n(...a),S()},o,s);let h;const u=()=>{var a;if(!c)return;d=!1,f.forEach(i=>i(o()));const g=((a=t.onRehydrateStorage)==null?void 0:a.call(t,o()))||void 0;return E(c.getItem.bind(c))(t.name).then(i=>{if(i)return t.deserialize(i)}).then(i=>{if(i)if(typeof i.version=="number"&&i.version!==t.version){if(t.migrate)return t.migrate(i.state,i.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return i.state}).then(i=>{var b;return h=t.merge(i,(b=o())!=null?b:l),n(h,!0),S()}).then(()=>{g?.(h,void 0),d=!0,v.forEach(i=>i(h))}).catch(i=>{g?.(void 0,i)})};return s.persist={setOptions:a=>{t={...t,...a},a.getStorage&&(c=a.getStorage())},clearStorage:()=>{c?.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>u(),hasHydrated:()=>d,onHydrate:a=>(f.add(a),()=>{f.delete(a)}),onFinishHydration:a=>(v.add(a),()=>{v.delete(a)})},u(),h||l},ve=(e,r)=>(n,o,s)=>{let t={storage:de(()=>localStorage),partialize:u=>u,version:0,merge:(u,a)=>({...a,...u}),...r},d=!1;const f=new Set,v=new Set;let c=t.storage;if(!c)return e((...u)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),n(...u)},o,s);const m=()=>{const u=t.partialize({...o()});return c.setItem(t.name,{state:u,version:t.version})},S=s.setState;s.setState=(u,a)=>{S(u,a),m()};const y=e((...u)=>{n(...u),m()},o,s);s.getInitialState=()=>y;let l;const h=()=>{var u,a;if(!c)return;d=!1,f.forEach(i=>{var b;return i((b=o())!=null?b:y)});const g=((a=t.onRehydrateStorage)==null?void 0:a.call(t,(u=o())!=null?u:y))||void 0;return E(c.getItem.bind(c))(t.name).then(i=>{if(i)if(typeof i.version=="number"&&i.version!==t.version){if(t.migrate)return[!0,t.migrate(i.state,i.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,i.state];return[!1,void 0]}).then(i=>{var b;const[O,C]=i;if(l=t.merge(C,(b=o())!=null?b:y),n(l,!0),O)return m()}).then(()=>{g?.(l,void 0),l=o(),d=!0,v.forEach(i=>i(l))}).catch(i=>{g?.(void 0,i)})};return s.persist={setOptions:u=>{t={...t,...u},u.storage&&(c=u.storage)},clearStorage:()=>{c?.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>h(),hasHydrated:()=>d,onHydrate:u=>(f.add(u),()=>{f.delete(u)}),onFinishHydration:u=>(v.add(u),()=>{v.delete(u)})},t.skipHydration||h(),l||y},me=(e,r)=>"getStorage"in r||"serialize"in r||"deserialize"in r?((ce?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),fe(e,r)):ve(e,r),ge=me;export{he as c,ge as p,ye as s};
